<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on perhapzz</title>
    <link>https://perhapzz.github.io/posts/</link>
    <description>Recent content in Posts on perhapzz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Feb 2023 20:59:17 +0800</lastBuildDate><atom:link href="https://perhapzz.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统笔记</title>
      <link>https://perhapzz.github.io/posts/operatingsystem/</link>
      <pubDate>Sat, 18 Feb 2023 20:59:17 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/operatingsystem/</guid>
      <description>操作系统 内核 内核作为应用连接硬件设备的桥梁，一般会提供 4 个基本能力：
 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力； 管理内存，决定内存的分配和回收，也就是内存管理的能力； 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力； 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。  大多数操作系统，把内存分成了两个区域：
 内核空间，这个内存空间只有内核程序可以访问； 用户空间，这个内存空间专门给应用程序使用；  应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：
内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。
Linux 的设计 Linux 内核设计的理念主要有这几个点：
 MultiTask，多任务 SMP，对称多处理 ELF，可执行文件链接格式 Monolithic Kernel，宏内核  MultiTask MultiTask 的意思是多任务，代表着 Linux 是一个多任务的操作系统。
多任务意味着可以有多个任务同时执行，这里的「同时」可以是并发或并行：
 对于单核 CPU 时，可以让每个任务执行一小段时间，时间到就切换另外一个任务，从宏观角度看，一段时间内执行了多个任务，这被称为并发。 对于多核 CPU 时，多个任务可以同时被不同核心的 CPU 同时执行，这被称为并行。  SMP SMP 的意思是对称多处理，代表着每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。
这个特点决定了 Linux 操作系统不会有某个 CPU 单独服务应用程序或内核程序，而是每个程序都可以被分配到任意一个 CPU 上被执行。
ELF ELF 的意思是可执行文件链接格式，它是 Linux 操作系统中可执行文件的存储格式，你可以从下图看到它的结构：</description>
    </item>
    
    <item>
      <title>青训营项目复盘</title>
      <link>https://perhapzz.github.io/posts/centrareview/</link>
      <pubDate>Thu, 16 Feb 2023 22:58:06 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/centrareview/</guid>
      <description>第五届字节跳动青训营简易抖音大项目复盘总结</description>
    </item>
    
    <item>
      <title>gorm-gen 学习笔记</title>
      <link>https://perhapzz.github.io/posts/gorm-gen/</link>
      <pubDate>Thu, 26 Jan 2023 00:24:03 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/gorm-gen/</guid>
      <description>gen 通过代码生成，让 GORM 更加友好（针对复杂SQL场景也能处理），也更加安全（增加类型校验）</description>
    </item>
    
    <item>
      <title>JWT 学习笔记</title>
      <link>https://perhapzz.github.io/posts/jwt/</link>
      <pubDate>Tue, 24 Jan 2023 00:46:44 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/jwt/</guid>
      <description>JSON Web Token（JWT）是一个轻量级的认证规范，这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息</description>
    </item>
    
    <item>
      <title>WSL 实操笔记</title>
      <link>https://perhapzz.github.io/posts/wsl/</link>
      <pubDate>Fri, 20 Jan 2023 00:39:18 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/wsl/</guid>
      <description>Windows Subsystem for Linux（简称WSL）是适用于Windows的Linux子系统</description>
    </item>
    
    <item>
      <title>Redis学习笔记</title>
      <link>https://perhapzz.github.io/posts/redis/</link>
      <pubDate>Sun, 25 Dec 2022 22:21:20 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/redis/</guid>
      <description>Redis Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。
Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。
除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。
为什么用 Redis 作为 MySQL 的缓存？ 主要是因为 Redis 具备「高性能」和「高并发」两种特性。
1、Redis 具备高性能
假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。
如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。
2、 Redis 具备高并发
单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。
所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
Redis 持久化 Redis 如何实现数据不丢失？ Redis 共有三种数据持久化的方式：</description>
    </item>
    
    <item>
      <title>计算机网络笔记</title>
      <link>https://perhapzz.github.io/posts/computernetwork/</link>
      <pubDate>Sat, 24 Dec 2022 22:31:05 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/computernetwork/</guid>
      <description>计算机网络 基础篇 1. TCP/IP 网络模型有哪几层？ 应用层 我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等（什么东东..）。
传输层 给应用层提供网络支持的。
有两个传输协议，分别是 TCP 和 UDP。
TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。
UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。（那为什么不直接用TCP呢？）
网络层 传输层协议只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层（Internet Layer）。
网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。
  寻址   我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。
因此，需要将 IP 地址分成两种意义：</description>
    </item>
    
    <item>
      <title>纸上谈Git</title>
      <link>https://perhapzz.github.io/posts/git/</link>
      <pubDate>Sat, 17 Dec 2022 10:04:52 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/git/</guid>
      <description>Git学习笔记</description>
    </item>
    
    <item>
      <title>CodeTop 刷题笔记</title>
      <link>https://perhapzz.github.io/posts/codetop/</link>
      <pubDate>Tue, 13 Dec 2022 19:48:31 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/codetop/</guid>
      <description>用 golang 刷 codetop</description>
    </item>
    
    <item>
      <title>迈出Go RPC的一小步</title>
      <link>https://perhapzz.github.io/posts/firststepofrpc/</link>
      <pubDate>Tue, 13 Dec 2022 10:52:29 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/firststepofrpc/</guid>
      <description>记Go语言远程过程调用RPC学习过程</description>
    </item>
    
    <item>
      <title>个人博客搭建笔记</title>
      <link>https://perhapzz.github.io/posts/personalblogsetupnote/</link>
      <pubDate>Mon, 12 Dec 2022 12:52:25 +0800</pubDate>
      
      <guid>https://perhapzz.github.io/posts/personalblogsetupnote/</guid>
      <description>记用hugo搭建个人博客的全过程</description>
    </item>
    
  </channel>
</rss>
