<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CodeTop 刷题笔记 | perhapzz</title>
<meta name="keywords" content="golang, algorithm">
<meta name="description" content="用 golang 刷 codetop">
<meta name="author" content="">
<link rel="canonical" href="https://perhapzz.github.io/posts/codetop/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2c5d624023ca4f39285dc8ad242509c565a0c0e820fc61724b2a58620dfdafbe.css" integrity="sha256-LF1iQCPKTzkoXcitJCUJxWWgwOgg/GFySypYYg39r74=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://perhapzz.github.io/favicon/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://perhapzz.github.io/favicon/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://perhapzz.github.io/favicon/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://perhapzz.github.io/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://perhapzz.github.io/favicon/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CodeTop 刷题笔记" />
<meta property="og:description" content="用 golang 刷 codetop" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://perhapzz.github.io/posts/codetop/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-13T19:48:31+08:00" />
<meta property="article:modified_time" content="2022-12-13T19:48:31+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CodeTop 刷题笔记"/>
<meta name="twitter:description" content="用 golang 刷 codetop"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://perhapzz.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "CodeTop 刷题笔记",
      "item": "https://perhapzz.github.io/posts/codetop/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CodeTop 刷题笔记",
  "name": "CodeTop 刷题笔记",
  "description": "用 golang 刷 codetop",
  "keywords": [
    "golang", "algorithm"
  ],
  "articleBody": "写在前面：\n大体以题目编号进行排序，也可以 ctrl+F 直接搜索题号、题名或者题目类型。\n3. 无重复字符的最长子串 滑动窗口 \n解题思路：\n我们先从0开始取一段满足题意的子串，然后移动窗口，加入右边界触碰到重复字符则把左边界移到该重复字符上一次出现位置的右侧，并消去中途经过字符的记录，每次移动比较子串长度，最后可以得到最长子串。\nfunc lengthOfLongestSubstring(s string) int {  alphabet := [500]int{}   // 先从0开始取一段  l, r := 0, 0 // 在s中取[l, r)  for ; r s) \u0026\u0026 alphabet[s[r]] == 0; r++ {  alphabet[s[r]] = r+1  }  // fmt.Println(s[l:r])  res := r-l   // 逐渐右移 l  for l s)-res {  for ; l alphabet[s[r]]; l++ {  alphabet[s[l]] = 0  }  for ; r s) \u0026\u0026 alphabet[s[r]] == 0; r++ {  alphabet[s[r]] = r+1  }  // fmt.Println(s[l:r])  if r-l  res {  res = r-l  }  }   return res } 优化：\n alphabet数组大小是我自己随便定的，可以用map来降低内存消耗 代码上有冗余部分，可以优化  func lengthOfLongestSubstring(s string) int {  alphabet := map[byte]int{}  l, r := 0, 0 // 在s中取[l, r)  res := 0   for l s)-res {  // 右移l，第一次会不变  for ; l alphabet[s[r]]; l++ {  delete(alphabet, s[l])  }  // 每次把r往右推到推不动为止  for ; r s) \u0026\u0026 alphabet[s[r]] == 0; r++ {  alphabet[s[r]] = r+1  }  if r-l  res {  res = r-l  }  }   return res } 现在代码看上去清爽一点，但不知道为什么执行时间和内存消耗都不如上一次。\n15. 三数之和 二分查找\n解题思路：\n题目给出的数据范围 3 ， 想想 $O(n^2lgn)$ 应该也能过，所以初步思路是双层遍历+二分查找。\nfunc threeSum(nums []int) (res [][]int) {  sort.Ints(nums)  n := len(nums)  for i := 0; i n; i++ {  if nums[i]  0 {  return  }  if i  0 \u0026\u0026 nums[i] == nums[i-1] {  continue  }  for j := i+1; j n; j++ {  if j  i+1 \u0026\u0026 nums[j] == nums[j-1] {  continue  }  pos := sort.SearchInts(nums[j+1:], -nums[i]-nums[j])  if pos+j+1 n \u0026\u0026 nums[pos+j+1] == -nums[i]-nums[j] {  res = append(res, []int{nums[i], nums[j], nums[pos+j+1]})  }  }  }  return res } 结果可以说只能勉强过。\n优化：\n 使用双指针，将时间复杂度降到 $O(n^2)$。  双指针\nfunc threeSum(nums []int) (res [][]int) {  sort.Ints(nums)  n := len(nums)  for i := 0; i n; i++ { \t// 防止重复三元组  for i  0 \u0026\u0026 i n \u0026\u0026 nums[i] == nums[i-1] {  i++  }  l, r := i+1, n-1  for l r {  // 移动双指针  // 如果总和较小，移动左指针调大总和，反之移动右指针调小总和  if nums[l] + nums[r] == -nums[i] {  res = append(res, []int{nums[i], nums[l], nums[r]})  l++  r--  } else if nums[l] + nums[r] -nums[i] {  l++  } else {  r--  }  // 防止重复三元组  for l  i+1 \u0026\u0026 l r \u0026\u0026 nums[l] == nums[l-1] {  l++  }  for r n-1 \u0026\u0026 l r \u0026\u0026 nums[r] == nums[r+1] {  r--  }  }   }  return res } 比原先好点儿。\n为了打败全世界的人，我还要优化：\n 因为整体是在升序数组上进行运算，当第一个 nums[i] 大于 0 时，后面已经不可能在有等于 0 的组合，可以直接 return。同理，当 nums[i] + nums[l] 大于 0 时，后面已经不可能出现等于 0 的组合，可以移动 i 了。 for 循环的开销还是非常大的，每次都要去重也不容易，改成当 l 或者 r 移动的时候才去重。  func threeSum(nums []int) (res [][]int) {  if len(nums) 3 {  return  }  sort.Ints(nums)  n := len(nums)  for i := 0; i n; i++ {  if nums[i]  0 {  return  } \t// 防止重复三元组  for i  0 \u0026\u0026 i n \u0026\u0026 nums[i] == nums[i-1] {  i++  }  l, r := i+1, n-1  for l r {  if nums[l] + nums[i]  0 {  break  }  // 移动双指针  // 如果总和较小，移动左指针调大总和，反之移动右指针调小总和  sum := nums[l] + nums[r] + nums[i]  if sum == 0 {  res = append(res, []int{nums[i], nums[l], nums[r]})  for l r \u0026\u0026 nums[l] == nums[l+1] {  l++  }  l++  for l r \u0026\u0026 nums[r] == nums[r-1] {  r--  }  r--  } else if sum 0 {  for l r \u0026\u0026 nums[l] == nums[l+1] {  l++  }  l++  } else {  for l r \u0026\u0026 nums[r] == nums[r-1] {  r--  }  r--  }  // 防止重复三元组  }  }  return res } 最终还是没有打败全世界的人，实在是太强了。\n33. 搜索旋转排序数组 二分查找 分类讨论\n解题思路：\n我们把数组想象为左边半段有序和右边半段有序，通过二分查找的思想，可以分情况讨论：\n 中间的数小于 target，我们可以根据以下情况判断应该保留左边还是右边：  中间的数属于左有序半段，则 target 必定在右半段 中间的数属于右有序半段，并且最右端那个数大于 target，则 target 必定在右半段 中间的数属于右有序半段，并且最右端那个数也小于 target，则 target 必定在左半段   中间的数大于 target：  中间的数属于右有序半段，则 target 必定在左半段 中间的数属于左有序半段，并且最左端那个数小于 target，则 target 必定在左半段 中间的数属于左有序半段，并且最右端那个数也大于 target，则 target 必定在右半段    func search(nums []int, target int) int {  n := len(nums)  l, r := 0, n-1  for l r {  mid := l + (r - l) / 2  if nums[mid] == target {  return mid  } else if nums[mid] target {  if nums[l]  nums[mid] || nums[r] = target {  l = mid+1  } else {  r = mid-1  }  } else if nums[l]  nums[mid] || nums[l]  target {  r = mid-1  } else {  l = mid+1  }  }  if nums[l] == target {  return l  }  return -1 } 146. LRU 缓存 双向链表 哈希表\n解题思路：\n用双向链表按使用顺序存储节点们，刚使用的节点放在表头位置，越久没用的数据将慢慢移动到表尾，当存储到达容量上限的时候，直接删除表尾节点就能逐出最久未使用的数据。其中使用双向链表的原因在于，找到节点位置后，方便移动。再通过哈希表存储各个节点位置，方便快速找到要查的节点，进行删除移动操作。\ntype Node struct {  Key int  Val int  Pre *Node  Next *Node }  type LRUCache struct {  m map[int]*Node  head *Node  len int  capacity int }  func Constructor(capacity int) LRUCache {  return LRUCache{  // 初始化 map  m: map[int]*Node{},  // 设置容量上限  capacity: capacity,  } }  func (this *LRUCache) Get(key int) int {  if pos, ok := this.m[key]; ok {  if pos == this.head {  return pos.Val  }  // 将节点拆出来，放到 head 位置  pos.Pre.Next = pos.Next  pos.Next.Pre = pos.Pre  pos.Next = this.head  pos.Pre = this.head.Pre  this.head.Pre.Next = pos  this.head.Pre = pos  this.head = pos  return pos.Val  }  return -1 }   func (this *LRUCache) Put(key int, value int) {  if this.head == nil {  this.head = \u0026Node {  Key: key,  Val: value,  }  this.head.Next = this.head  this.head.Pre = this.head  this.m[key] = this.head  this.len++  return  }   if pos, ok := this.m[key]; ok {  // 如果存在  if this.head != pos {  // 且节点并非在 head 位置  // 将节点拆出来，放到 head 位置  pos.Pre.Next = pos.Next  pos.Next.Pre = pos.Pre  pos.Pre = this.head.Pre  pos.Next = this.head  this.head.Pre.Next = pos  this.head.Pre = pos  this.head = pos  }  pos.Val = value  } else if this.len == this.capacity {  // 容量到达上限的时候，先删除尾节点  delete(this.m, this.head.Pre.Key)  // 在 head 位置加节点  this.head = this.head.Pre  this.m[key] = this.head  this.head.Key = key  this.head.Val = value  } else {  // 容量没有到达上限，直接在头部增加新节点，并把长度加一  this.len++  newnode := \u0026Node {  Key: key,  Val: value,  Pre: this.head.Pre,  Next: this.head,  }  this.head.Pre.Next = newnode  this.head.Pre = newnode  this.head = newnode  this.m[key] = newnode  }   return } 优化：\n 使用双向链表操作中有很多重复代码，比如在头部增加节点、移动节点打表头，可以增加使用 ListManager 来维护双向链表  300. 最长上升子序列 动态规划\n解题思路：\n从数据范围来看，1 的话用 $O(n^2)$ 的 dp 方法就可以解决了。\nfunc lengthOfLIS(nums []int) int {  n := len(nums)  dp := make([]int, n)  res := 1  for i := 0; i n; i++ {  dp[i] = 1  for j := 0; j i; j++ {  if nums[i]  nums[j] {  dp[i] = max(dp[i], dp[j]+1)  res = max(res, dp[i])  }  }  }  return res }  func max(x, y int) int {  if x  y {  return x  }  return y } 看到题解才发现这个方法，维护一个数组 d，d[i] 代表长度为 i 的最长上升子序列的末尾元素的最小值，我们的目标是使 d[i] 上的数字尽可能地小。那么每次遍历的过程中每遇到一个新的数，尝试把它加入 d[i]，这时有两种情况，它是最大的，可以直接加在队尾；或者可以放入其中，代替一个比他大的数。最后结果就是这个数组能够有多长。最后时间复杂度为 $O(nlgn)$！\n动态规划 二分查找\nfunc lengthOfLIS(nums []int) int {  n := len(nums)  d := []int{nums[0]}  for i := 1; i n; i++ {  if nums[i]  d[len(d)-1] {  d = append(d, nums[i])  } else {  pos := sort.SearchInts(d, nums[i])  d[pos] = nums[i]  }  }  return len(d) } ",
  "wordCount" : "1085",
  "inLanguage": "en",
  "datePublished": "2022-12-13T19:48:31+08:00",
  "dateModified": "2022-12-13T19:48:31+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://perhapzz.github.io/posts/codetop/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "perhapzz",
    "logo": {
      "@type": "ImageObject",
      "url": "https://perhapzz.github.io/favicon/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://perhapzz.github.io" accesskey="h" title="perhapzz (Alt + H)">perhapzz</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://perhapzz.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://perhapzz.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://perhapzz.github.io">Home</a>&nbsp;»&nbsp;<a href="https://perhapzz.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      CodeTop 刷题笔记
    </h1>
    <div class="post-description">
      用 golang 刷 codetop
    </div>
    <div class="post-meta"><span title='2022-12-13 19:48:31 +0800 CST'>December 13, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>写在前面：</p>
<p>大体以题目编号进行排序，也可以 <code>ctrl+F</code>  直接搜索题号、题名或者题目类型。</p>
<h1 id="3-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">3. 无重复字符的最长子串</a><a hidden class="anchor" aria-hidden="true" href="#3-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters">#</a></h1>
<p><code>滑动窗口 </code></p>
<p><strong>解题思路：</strong></p>
<p>我们先从0开始取一段满足题意的子串，然后移动窗口，加入右边界触碰到重复字符则把左边界移到该重复字符上一次出现位置的右侧，并消去中途经过字符的记录，每次移动比较子串长度，最后可以得到最长子串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alphabet</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">500</span>]<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 先从0开始取一段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>    <span style="color:#75715e">// 在s中取[l, r)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">r</span> &lt; len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">r</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] = <span style="color:#a6e22e">r</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fmt.Println(s[l:r])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 逐渐右移 l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">res</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]]; <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">l</span>]] = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">r</span> &lt; len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">r</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] = <span style="color:#a6e22e">r</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// fmt.Println(s[l:r])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span> &gt; <span style="color:#a6e22e">res</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202212132008975.png" alt="image-20221213200815724"  />
</p>
<p><strong>优化：</strong></p>
<ol>
<li>alphabet数组大小是我自己随便定的，可以用map来降低内存消耗</li>
<li>代码上有冗余部分，可以优化</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alphabet</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">byte</span>]<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>    <span style="color:#75715e">// 在s中取[l, r)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">res</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 右移l，第一次会不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]]; <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            delete(<span style="color:#a6e22e">alphabet</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">l</span>])
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 每次把r往右推到推不动为止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">r</span> &lt; len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">r</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">alphabet</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>]] = <span style="color:#a6e22e">r</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span> &gt; <span style="color:#a6e22e">res</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#a6e22e">l</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在代码看上去清爽一点，但不知道为什么执行时间和内存消耗都不如上一次。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202212132009062.png" alt="image-20221213200903893"  />
</p>
<h1 id="15-三数之和httpsleetcodecnproblems3sum"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a><a hidden class="anchor" aria-hidden="true" href="#15-三数之和httpsleetcodecnproblems3sum">#</a></h1>
<p><code>二分查找</code></p>
<p><strong>解题思路：</strong></p>
<p>题目给出的数据范围 <code>3 &lt;= nums.length &lt;= 3000</code>， 想想 $O(n^2lgn)$ 应该也能过，所以初步思路是双层遍历+二分查找。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">threeSum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> &gt; <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">SearchInts</span>(<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], <span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]<span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> &lt; <span style="color:#a6e22e">n</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]<span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]})
</span></span><span style="display:flex;"><span>            }   
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结果可以说只能勉强过。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162008619.png" alt="image-20230216200823373"  />
</p>
<p><strong>优化：</strong></p>
<ol>
<li>使用双指针，将时间复杂度降到 $O(n^2)$。</li>
</ol>
<p><code>双指针</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">threeSum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 防止重复三元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> {
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// 移动双指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          	<span style="color:#75715e">// 如果总和较小，移动左指针调大总和，反之移动右指针调小总和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>]})
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] &lt; <span style="color:#f92672">-</span><span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 防止重复三元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &gt; <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            } 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">r</span> &lt; <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比原先好点儿。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162051541.png" alt="image-20230216202210961"  />
</p>
<p>为了打败全世界的人，我还要<strong>优化：</strong></p>
<ol>
<li>因为整体是在升序数组上进行运算，当第一个 <code>nums[i]</code> 大于 0 时，后面已经不可能在有等于 0 的组合，可以直接 return。同理，当 <code>nums[i] + nums[l]</code> 大于 0 时，后面已经不可能出现等于 0 的组合，可以移动 <code>i</code> 了。</li>
<li><code>for</code> 循环的开销还是非常大的，每次都要去重也不容易，改成当 <code>l</code> 或者 <code>r</code> 移动的时候才去重。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">threeSum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) &lt; <span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 防止重复三元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// 移动双指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          	<span style="color:#75715e">// 如果总和较小，移动左指针调大总和，反之移动右指针调小总和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>]})
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                } 
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sum</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                } 
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 防止重复三元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最终还是没有打败全世界的人，实在是太强了。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162051073.png" alt="image-20230216203716574"  />
</p>
<h1 id="33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-array"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a><a hidden class="anchor" aria-hidden="true" href="#33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-array">#</a></h1>
<p><code>二分查找</code> <code>分类讨论</code></p>
<p><strong>解题思路：</strong></p>
<p>我们把数组想象为左边半段有序和右边半段有序，通过二分查找的思想，可以分情况讨论：</p>
<ol>
<li>中间的数小于 <code>target</code>，我们可以根据以下情况判断应该保留左边还是右边：
<ol>
<li>中间的数属于左有序半段，则 <code>target</code> 必定在右半段</li>
<li>中间的数属于右有序半段，并且最右端那个数大于 <code>target</code>，则 <code>target</code> 必定在右半段</li>
<li>中间的数属于右有序半段，并且最右端那个数也小于 <code>target</code>，则  <code>target</code> 必定在左半段</li>
</ol>
</li>
<li>中间的数大于 <code>target</code>：
<ol>
<li>中间的数属于右有序半段，则 <code>target</code> 必定在左半段</li>
<li>中间的数属于左有序半段，并且最左端那个数小于 <code>target</code>，则 <code>target</code> 必定在左半段</li>
<li>中间的数属于左有序半段，并且最右端那个数也大于 <code>target</code>，则  <code>target</code> 必定在右半段</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">search</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> &lt; <span style="color:#a6e22e">r</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">+</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">l</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mid</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>] &lt; <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>] <span style="color:#f92672">||</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">r</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">r</span> = <span style="color:#a6e22e">mid</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] &gt; <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>] <span style="color:#f92672">||</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">r</span> = <span style="color:#a6e22e">mid</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162141567.png" alt="image-20230216214024197"  />
</p>
<h1 id="146-lru-缓存httpsleetcodecnproblemslru-cache"><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a><a hidden class="anchor" aria-hidden="true" href="#146-lru-缓存httpsleetcodecnproblemslru-cache">#</a></h1>
<p><code>双向链表</code> <code>哈希表</code></p>
<p><strong>解题思路：</strong></p>
<p>用双向链表按使用顺序存储节点们，刚使用的节点放在表头位置，越久没用的数据将慢慢移动到表尾，当存储到达容量上限的时候，直接删除表尾节点就能逐出最久未使用的数据。其中使用双向链表的原因在于，找到节点位置后，方便移动。再通过哈希表存储各个节点位置，方便快速找到要查的节点，进行删除移动操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Key</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Val</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Pre</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LRUCache</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">capacity</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Constructor</span>(<span style="color:#a6e22e">capacity</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">LRUCache</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">LRUCache</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 初始化 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">m</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>{},
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置容量上限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">capacity</span>: <span style="color:#a6e22e">capacity</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LRUCache</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pos</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pos</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将节点拆出来，放到 head 位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LRUCache</span>) <span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>)  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Key</span>: <span style="color:#a6e22e">key</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">len</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pos</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pos</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 且节点并非在 head 位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 将节点拆出来，放到 head 位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pos</span>.<span style="color:#a6e22e">Val</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">len</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">capacity</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 容量到达上限的时候，先删除尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        delete(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Key</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在 head 位置加节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Key</span> = <span style="color:#a6e22e">key</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Val</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 容量没有到达上限，直接在头部增加新节点，并把长度加一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">len</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newnode</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Key</span>: <span style="color:#a6e22e">key</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Pre</span>: <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Next</span>: <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">newnode</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Pre</span> = <span style="color:#a6e22e">newnode</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">newnode</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">newnode</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302141241048.png" alt="image-20230214124147520"  />
</p>
<p><strong>优化：</strong></p>
<ol>
<li>使用双向链表操作中有很多重复代码，比如在头部增加节点、移动节点打表头，可以增加使用 <code>ListManager</code> 来维护双向链表</li>
</ol>
<h1 id="300-最长上升子序列httpsleetcodecnproblemslongest-increasing-subsequence"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长上升子序列</a><a hidden class="anchor" aria-hidden="true" href="#300-最长上升子序列httpsleetcodecnproblemslongest-increasing-subsequence">#</a></h1>
<p><code>动态规划</code></p>
<p><strong>解题思路：</strong></p>
<p>从数据范围来看，<code>1 &lt;= nums.length &lt;= 2500</code> 的话用 $O(n^2)$ 的 dp 方法就可以解决了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lengthOfLIS</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">i</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">j</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &gt; <span style="color:#a6e22e">y</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162051301.png" alt="image-20230216204649728"  />
</p>
<p>看到题解才发现这个方法，维护一个数组 <code>d</code>，<code>d[i]</code> 代表长度为 <code>i</code> 的最长上升子序列的末尾元素的最小值，我们的目标是使 <code>d[i]</code> 上的数字尽可能地小。那么每次遍历的过程中每遇到一个新的数，尝试把它加入 <code>d[i]</code>，这时有两种情况，它是最大的，可以直接加在队尾；或者可以放入其中，代替一个比他大的数。最后结果就是这个数组能够有多长。最后时间复杂度为 $O(nlgn)$！</p>
<p><code>动态规划</code> <code>二分查找</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lengthOfLIS</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">nums</span>[<span style="color:#ae81ff">0</span>]}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">d</span>[len(<span style="color:#a6e22e">d</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">d</span> = append(<span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">SearchInts</span>(<span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">d</span>[<span style="color:#a6e22e">pos</span>] = <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/perhapzz/ImageBed/main/blog-images/202302162145499.png" alt="image-20230216212443592"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://perhapzz.github.io/tags/golang/">golang</a></li>
      <li><a href="https://perhapzz.github.io/tags/algorithm/">algorithm</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://perhapzz.github.io">perhapzz</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
